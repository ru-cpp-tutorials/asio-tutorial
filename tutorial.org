#+AUTHOR: Daniil Shvalov
#+EMAIL: daniil.shvalov@gmail.com
# #+TITLE: ...
#+LANGUAGE: ru
#+EXPORT_FILE_NAME: TUTORIAL.md
#+OPTIONS: toc:nil

* Содержание
:PROPERTIES:
:TOC:      :include all :depth 3 :force (nothing) :ignore (this) :local (nothing)
:END:
:CONTENTS:
- [[#введение][Введение]]
- [[#tcp-и-udp][TCP и UDP]]
  - [[#transmission-control-protocol--tcp][Transmission Control Protocol — TCP]]
  - [[#user-datagram-protocol--udp][User Datagram Protocol — UDP]]
- [[#самый-простой-сервер][Самый простой сервер]]
- [[#прощаемся-с-синхронностью][Прощаемся с синхронностью]]
- [[#асинхронный-tcp-сервер][Асинхронный TCP-сервер]]
:END:




* Введение
:PROPERTIES:
:CUSTOM_ID: введение
:END:

Данное руководство посвящено работе асинхронного ввода-вывода, который в основном используется для сетевого взаимодействия. Для лучшего понимания происходящего, вы должны быть знакомы с современным C++, STL и Boost, а также с базовыми принципами сетевого взаимодействия и многопоточности.

Мы будем использовать ~Boost.Asio~, ~Boost.Beast~, а также ~C++20 Networking library~. Чтобы добиться асинхронности, мы будем использовать /обработчики завершения/, /сопрограммы/ (или корутины) и /фиберы/.

Чтобы скомпилировать исходный код из примеров, вам понадобиться установить компилятор, поддерживающий стандарт ~C++17~, а также библиотеку ~Boost~. При компиляции вам потребуется добавить ~Boost~ в ~include directories~ и слинковать исходный код вашего приложения с ним.

На самом деле, для большинства примеров достаточно скомпилировать ~boost/libs/system/src/error_code.cpp~, поскольку остальная часть исходного кода библиотеки ~Boost~ — это header-only библиотеки.

Обычно сетевое взаимодействие считается очень сложным предметом для изучения. Неужели это действительно так сложно? Что ж, ответ — и да, и нет. Потребуется время, чтобы стать экспертом в этой области, однако мы попробуем сделать так, чтобы вам было понятно то, что происходит в этом руководстве.

Когда вы разрабатываете какое-либо приложение, вам следует использовать пространства имен (namespaces) и псевдонимы типов (type aliases), чтобы код было удобно читать. Мы начнем это делать позднее, после того, как у вас появится четкое понимание откуда берутся те или иные вещи. Поэтому первое время вы будете видеть что-то по типу ~boost::asio::ip::tcp::socket~. Конечно же, в реальном коде это должно быть заменено на что-то вроде ~tcp::socket~.

Двумя важными элементами сетевого взаимодействия являются /клиенты/ и /серверы/. Обычно подобные руководства начинаются с изучения работы клиента, поскольку это более простая тема для рассмотрения. Однако в этом руководстве мы начнем с серверов. Почему? Во-первых, сервера — это то место, где C++ проявляет себя с наилучшей стороны, а во-вторых, сервера не так страшны, как кажутся на первый взгляд.

На этом вступление окончено. Теперь вы готовы приступить к погружению в сетевое программирование на C++.

* TCP и UDP
:PROPERTIES:
:CUSTOM_ID: tcp-и-udp
:END:

Существует два основных протокола транспортного уровня, которые мы будем использовать — TCP и UDP. Протокол — это набор соглашений о том, как должны передаваться данные по сети.

** Transmission Control Protocol — TCP
:PROPERTIES:
:CUSTOM_ID: transmission-control-protocol--tcp
:END:

TCP-соединение очень похоже на файл: мы открываем его, считываем из него какие-то данные, записываем какие-то данные и закрываем его. Однако существуют некоторые ограничения:
- При работе с файлом мы можем узнать его размер. В случае TCP-соединения это невозможно.
- Вы можете изменять положение указателя, когда работаете с файлом. Этот трюк также нельзя провернуть с TCP-соединением.

Другими словами, файл предоставляет вам произвольный доступ, в то время как TCP-соединение представляет собой двунаправленный последовательный поток.

** User Datagram Protocol — UDP
:PROPERTIES:
:CUSTOM_ID: user-datagram-protocol--udp
:END:

Информация, передаваемая по протоколу UDP, представляет собой непрерывный кусок данных. По сравнению с TCP, у UDP нет соединений. Невозможно получить только часть данных, отправленных приложением. Вы либо получите все данные, либо ничего. На данный момент вам нужно знать о UDP следующее:
- В UDP отсутствуют соединения, поскольку это не поток данных. Из этого следует, что нет необходимости создавать или закрывать UDP-сокет. Все, что вам требуется — это отправлять или получать данные.
- Буфер, используемый для получения UDP-пакета должен быть достаточно большим, чтобы вместить весь пакет целиком. В противном случае, вы ничего не получите. Из этого следует, что необходимо заранее знать верхнюю границу размера пакетов, которые вы собрались получать.
- Порядок входящих пакетов, как правило, не соответствует порядку их отправки. Это означает, что необходимо самостоятельно контролировать порядок пакетов.
- Нет никаких гарантий, что все отправленные пакеты будут доставлены. Это означает, что потеря UDP-пакетов — обычное дело. Следовательно, необходимо самостоятельно контролировать, что все отправленные UDP-пакеты доставлены.

Как вы можете понять, UDP немного сложнее в использовании, чем TCP. Тем не менее, у UDP есть свои преимущества, которые мы обсудим позднее.

Это все, что вам необходимо знать о протоколах на данный момент. Значит, мы можем двигаться дальше.

* Самый простой сервер
:PROPERTIES:
:CUSTOM_ID: самый-простой-сервер
:END:

Согласно [[https://ru.wikipedia.org/wiki/Сервер_(программное_обеспечение)][Википедии]],
#+begin_quote
Сервер — программный компонент вычислительной системы, выполняющий сервисные (обслуживающие) функции по запросу клиента, предоставляя ему доступ к определённым ресурсам или услугам.
#+end_quote

Это определение очень точно подмечает тот факт, что сервер — это всего лишь приложение, которое получает какие-то данные от других приложений и возвращает некоторые данные обратно.

Мы начнем с самого простого сервера, который приходит на ум — эхо UDP-сервер. Он выполняет следующие действия:
- Получает любые данные, которые были отправлены на UDP-порт 15001.
- Отправляет полученные данные обратно отправителю «как есть».

На самом деле вы можете выбрать практически любой порт для вашего сервера. Существует множество часто используемых портов для различных служб, которые вы можете найти здесь: [[https://ru.wikipedia.org/wiki/Список_портов_TCP_и_UDP][Список портов TCP и UDP]]. Однако, как правило, только несколько из этих служб используется одновременно в недавно установленной ОС.

<<code:simple_server>>
Теперь давайте взглянем на следующий [[./code/simple_server.cpp][исходный код]]:
#+begin_src cpp :tangle code/simple_server.cpp
#include <boost/asio.hpp> (ref:simple_server)

int main() {
    std::uint16_t port = 15001;

    boost::asio::io_context io_context;
    boost::asio::ip::udp::endpoint receiver(boost::asio::ip::udp::v4(), port);
    boost::asio::ip::udp::socket socket(io_context, receiver);

    while (true) {
        char buffer[65536];
        boost::asio::ip::udp::endpoint sender;
        std::size_t bytes_transferred =
            socket.receive_from(boost::asio::buffer(buffer), sender);
        socket.send_to(boost::asio::buffer(buffer, bytes_transferred), sender);
    }

    return 0;
}
#+end_src

Вам даже не обязательно отдельно скачивать ~.cpp~ файл сервера, поскольку вышеприведенный код — это полноценный эхо UDP-сервер. Мы не реализовали логирование и обработку ошибок, чтобы код выглядел максимально просто. Об обработке ошибок мы поговорим позднее. Давайте разберемся, что происходит в этом коде:
- ~boost::asio::io_context~ — основной поставщик услуг ввода-вывода. В данный момент вы можете рассматривать его как исполнителя (executor) запланированных задач. Вы поймете его назначение сразу после того, как мы перейдем к асинхронному потоку управления, что произойдет очень скоро.
- ~boost::asio::ip::udp::endpoint~ — это пара IP-адреса и порта.
- ~boost::asio::ip::udp::socket~ — это сокет. Вы можете рассматривать его как дескриптор файла, предназначенный для сетевого взаимодействия. Обычно, когда вы открываете файл, вы получаете дескриптор файла. Когда вы взаимодействуете по сети, вы используете сокет.
- Каждый сокет прикреплен к некоторому ~io_context~, а потому каждый сокет конструируется с помощью ссылки на ~io_context~. Второй параметр конструктора сокета — ~endpoint~ — IP-адрес и порт, который используется для получения входящих дейтаграмм (в случае UDP) или соединений (в случае TCP).
- ~boost::asio::ip::udp::v4()~ возвращает объект, который в данный момент вы должны рассматривать как просто сетевой интерфейс UDP по умолчанию.
- ~boost::asio::buffer()~ — это представление буфера, которое содержит указатель и размер, причем это представление не владеет памятью. В нашем случае оно указывает на массив ~char~.
- ~socket::receive_from~ ожидает входящий UDP-пакет, заполняет ~buffer~ полученными данными, а также заполняет ~sender~ информацией об отправителе, которая также включает в себя пару IP-адреса и порта.
- ~socket::send_to~ отправляет UDP-пакет, используя данные из представления буфера. Получатель пакета передается вторым аргументом. В нашем случае получателем является отправитель, поскольку речь идет об эхо-сервере.

Итак, мы сделали следующее:
- Создали UDP-сокет и настроили его на ожидание UDP-пакетов на порту 15001.
- Запустили бесконечный цикл, в котором ожидаем входящие UDP-пакеты, а после получения отправляем их обратно отправителю.

Поздравляем! Вы только что создали ваш первый сервер с помощью C++ и Boost.Asio!

* Прощаемся с синхронностью
:PROPERTIES:
:CUSTOM_ID: прощаемся-с-синхронностью
:END:

В реальной жизни синхронный ввод-вывод практически бесполезен. Даже если вы пишите простой клиент с единственным сетевым подключением, то скорее всего ваше приложение будет выполнять такие функции как управление пользовательским интерфейсом, чтение пользовательского ввода и т. п. Однако использование синхронного ввода-вывода означает, что все его операции являются блокирующими. Следовательно ваше приложение не сможет выполнять каких либо операций до тех пор, пока не завершатся операции с вводом-выводом.

Вы можете обойти это ограничение с помощью создания дополнительных потоков. Например, один поток может обрабатывать ввод-вывод, а другой управлять пользовательским интерфейсом. Однако такой подход приведет к усложнению вашего приложения, поскольку в какой-то момент вам придется синхронизировать эти потоки. Более того, не существует безопасного способа отменить блокирующую операцию ввода-вывода из другого потока. Хотя это и может работать так, как вы ожидаете, но в целом это не безопасная операция. А потому вы можете столкнуться с неопределенным поведением, если что-нибудь измениться в вашем рабочем окружении (например, если вы скомпилируете код для новой платформы, с которой вы раньше не работали).

Асинхронный подход лишен этих недостатков. Проще говоря, выполнение асинхронного кода можно представить так: «Начни делать это в фоновом режиме, а после того, как закончишь, вызови эту функцию. Тем временем я займусь другими задачами, которые необходимо выполнить». Таким образом, выполнение асинхронного кода — это неблокирующая операция, а значит вы можете совершать другие действия, пока ваши задачи выполняются в фоновом режиме. Кроме того, асинхронные задачи могут быть безопасно отменены в любое время.

Вспомним [[code:simple_server][код из предыдущего раздела]], в котором используется синхронный подход:
#+begin_src cpp
// Эта операция заблокирует поток управление до тех пор, пока не будет получено сообщение
std::size_t bytes_transferred = socket.receive_from(buffer, sender);
std::cout << "Message is received, message size is " << bytes_transferred;
#+end_src

Асинхронные версии функций ввода-вывода в Boost.Asio начинаются с приставки ~async_~. Теперь взгляните на тот же код, переписанный в асинхронном стиле:
#+begin_src cpp
// Эта операция не блокирующая: выполнение кода продолжится сразу после вызова функции
socket.async_receive_from(
    buffer,
    sender,
    [&](boost::system::error_code error, std::size_t bytes_transferred) {
        // Эта лямбда-функция будет вызвана после получения сообщения
        std::cout << "Message is received, message size is "
                  << bytes_transferred;
    });
#+end_src

В C++ нам нравится держать все под контролем. Первое, что вы должны спросить: «Эй, где именно выполняется это фоновая задача? Должны ли мы создавать поток для нее?». Вы получите ответ на этот вопрос в следующем разделе. А пока, пришло время сказать «прощай» синхронному коду и двигаться дальше.

* Асинхронный TCP-сервер
:PROPERTIES:
:CUSTOM_ID: асинхронный-tcp-сервер
:END:

Пришло время взглянуть на наш первый асинхронный TCP-сервер. Это последний раз, когда мы не используем пространства имен (namespaces) и псевдонимы типов (type aliases). В дальнейшем вы уже должны понимать откуда берутся те или иные вещи.

Теперь наш сервер будет делать следующее:
- Слушать порт 15001 и ожидать входящее TCP-соединение.
- Принимать входящее соединение.
- Читать данные из соединения до тех пор, пока не встретится символ конца строки (т. е. символ ~\n~).
- Выводить полученные данные в стандартный вывод.
- Закрывать соединение.

Теперь давайте взглянем на полноценный пример такого сервера. Ниже мы все разложим по полочкам и посмотрим как все устроено. Как и прежде, мы пренебрегаем обработкой ошибок, чтобы код выглядел более понятным. Об обработке ошибок мы поговорим позже.

#+begin_src cpp :tangle code/tcp_async_server.cpp
#include <boost/asio.hpp>

#include <iostream>
#include <optional>

class session: public std::enable_shared_from_this<session> {
  public:
    session(boost::asio::ip::tcp::socket&& socket) :
        socket(std::move(socket)) {}

    void start() {
        boost::asio::async_read_until(
            socket,
            streambuf,
            '\n',
            [self = shared_from_this()](
                boost::system::error_code error,
                std::size_t bytes_transferred) {
                std::cout << std::istream(&self->streambuf).rdbuf();
            });
    }

  private:
    boost::asio::ip::tcp::socket socket;
    boost::asio::streambuf streambuf;
};

class server {
  public:
    server(boost::asio::io_context& io_context, std::uint16_t port) :
        io_context(io_context),
        acceptor(
            io_context,
            boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)) {}

    void async_accept() {
        socket.emplace(io_context);

        acceptor.async_accept(*socket, [&](boost::system::error_code error) {
            std::make_shared<session>(std::move(*socket))->start();
            async_accept();
        });
    }

  private:
    boost::asio::io_context& io_context;
    boost::asio::ip::tcp::acceptor acceptor;
    std::optional<boost::asio::ip::tcp::socket> socket;
};

int main() {
    boost::asio::io_context io_context;
    server srv(io_context, 15001);
    srv.async_accept();
    io_context.run();
    return 0;
}
#+end_src

По сравнению с предыдущим сервером, этот код занимает значительно больше места. Но не стоит паниковать, здесь всего 57 строк кода, которые представляют из себя полноценный асинхронный TCP-сервер.

В прошлый раз мы упомянули, что все функции с приставкой ~async_~ выполняются в фоновом режиме. Так где же находится этот «фоновый режим»? Что ж, фоновый режим находится /где-то/ внутри операционной системы. На самом деле, вам не нужно заботиться о том, как это происходит. Единственное, что должно вас волновать — откуда вызываются обработчики завершения. И это происходит внутри ~io_context.run()~. Давайте взглянем на функцию ~main~:
#+begin_src cpp
int main() {
    boost::asio::io_context io_context;
    server srv(io_context, 15001);
    srv.async_accept();
    io_context.run();
    return 0;
}
#+end_src

Функция ~boost::asio::io_context::run~ — это своего рода функция цикла событий (event loop), которая управляет всеми операциями ввода-вывода. При вызове функции ~run~ поток управления блокируется до тех пор, пока не выполнятся все асинхронные операции, связанные с ~io_context~. Все операции с приставкой ~async_~ связаны с каким-либо ~io_context~. В некоторых языках программирования (например, JavaScript) функция цикла событий спрятана от разработчика. Но в C++ нам нравится все держать под контролем, поэтому мы решаем, где именно функция цикла событий будет запущена.

Теперь давайте рассмотрим класс ~server~. Здесь встречается сразу несколько новых вещей, которые находятся в ~private~ секции класса:
- ~boost::asio::ip::tcp::socket~ — этот тот же самый сокет, что и до этого, только теперь он работает в рамках протокола TCP (вместо UDP, как это было ранее).
- ~boost::asio::ip::tcp::acceptor~ — это объект, который принимает входящие соединения.

Если вы посмотрите на конструктор класса ~acceptor~, вы увидите то, что он очень похож на метод ~receive_from~ у UDP-сокета:
#+begin_src cpp
acceptor(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port))
#+end_src

Передав такие аргументы конструктору, мы получим, что ~acceptor~ будет слушать входящие TCP-соединения на любом сетевом интерфейсе на указанном порту.

Теперь давайте рассмотрим вызов функциюю ~async_accept~ у ~acceptor~:
#+begin_src cpp
acceptor.async_accept(*socket, [&](boost::system::error_code error) {
    std::make_shared<session>(std::move(*socket))->start();
    async_accept();
});
#+end_src

Словами это можно описать так: «Ожидай входящее соединение, а после того как установишь его, свяжи это соединение с сокетом и вызови обработчик завершения». Как вы помните, функции с приставкой ~async_~ не блокируют вызывающий поток.

Итак, сервер ожидает входящее соединение После установления соединения сервер создает объект сессии. При создании мы перемещаем сокет, связанный с установленным соединением, внутрь объекта сессии. После этого сервер начинает ожидать следующее входящее соединение.

Обратите внимание, что серверу все равно, что происходит с установленным соединением. Сервер сразу же начинает ожидать следующее входящее соединение не беспокоясь о том, что происходит с предыдущим соединением. Установленные соединения выполняются в фоновом режиме. Одновременно может существовать почти любое количество соединений (количество открытых файловых дескрипторов ограничено ОС), выполняемых в фоновом режиме. Это и есть принцип работы асинхронного ввода-вывода.

Отлично, теперь мы знаем, как работает наш сервер. Давайте рассмотрим класс ~session~. Сессия — это класс, который поддерживает соединение. Сессия содержит некоторые данные, связанные с соединением и предоставляет некоторый набор функций, связанный с соединением. Давайте рассмотрим функцию ~start~:
#+begin_src cpp
void start() {
    boost::asio::async_read_until(
        socket,
        streambuf,
        '\n',
        [self = shared_from_this()](
            boost::system::error_code error,
            std::size_t bytes_transferred) {
            std::cout << std::istream(&self->streambuf).rdbuf();
        });
}
#+end_src

Дословно, код выполняет следующее: «Читай данные из сокета в ~streambuf~, а когда встретишь символ ~"\n"~, остановись и вызови обработчик завершения».

~boost::asio::streambuf~ — это класс, унаследованный от ~std::streambuf~. Можете рассматривать его как реализацию ~streambuf~ в библиотеке ~Boost.Asio~.

Итого, сессия считывает данные из сокета до тех пор, пока не встретит символ ~"\n"~, а после записывает полученные данные в стандартный вывод.

Обратите внимание, что класс ~session~ унаследован от класса ~std::enable_shared_from_this~. Также заметим, что сессия захватывает в лямбду обработчика завершения указатель на shared копию себя посредством ~shared_from_this~. Мы делаем это, чтобы продлить время жизни сессии до тех пор, пока не будет вызван обработчик завершения. После этого нам не нужно ничего делать — указатель на shared копию выйдет из области видимости и сразу же уничтожится после завершения работы обработчика. В большинстве случаев (но не во всех), это обычный способ для работы с сессиями.

Теперь вы знаете как написать простой асинхронный TCP-сервер и как он работает. Последнее, что нам необходимо сделать — протестировать в реальной жизни. Запустим сервер в терминале:
#+begin_src shell
./server
#+end_src

Теперь в другом терминале запустим ~telnet~, подключимся к 15001 порту, введем ~Hello asio!~ и нажмем ~Enter~ (который введет ожидаемый символ ~"\n"~):
#+begin_src shell
telnet localhost 15001
Hello asio!
#+end_src

В первом терминале вы должны увидеть это сообщение:
#+begin_src shell
./server
Hello asio!
#+end_src

Круто! Вы только начали, а уже знаете, как написать почти любой профессиональный асинхронный TCP-сервер с помощью современного C++ и Boost.Asio. Поздравляем!
