
# &#1057;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1085;&#1080;&#1077;

1.  [Введение](#org504f6ba)
2.  [TCP и UDP](#orgd89f8a1)
    1.  [Transmission Control Protocol — TCP](#org0185056)
    2.  [User Datagram Protocol — UDP](#orga3ceb8c)



<a id="org504f6ba"></a>

# Введение

Данное руководство посвящено работе асинхронного ввода-вывода, который в основном используется для сетевого взаимодействия. Для лучшего понимания происходящего, вы должны быть знакомы с современным C++, STL и Boost, а также с базовыми принципами сетевого взаимодействия и многопоточности.

Мы будем использовать `Boost.Asio`, `Boost.Beast`, а также `C++20 Networking library`. Чтобы добиться асинхронности, мы будем использовать *обработчики завершения*, *сопрограммы* (или корутины) и *фиберы*.

Чтобы скомпилировать исходный код из примеров, вам понадобиться установить компилятор, поддерживающий стандарт `C++17`, а также библиотеку `Boost`. При компиляции вам потребуется добавить `Boost` в `include directories` и слинковать исходный код вашего приложения с ним.

На самом деле, для большинства примеров достаточно скомпилировать `boost/libs/system/src/error_code.cpp`, поскольку остальная часть исходного кода библиотеки `Boost` — это header-only библиотеки.

Обычно сетевое взаимодействие считается очень сложным предметом для изучения. Неужели это действительно так сложно? Что ж, ответ — и да, и нет. Потребуется время, чтобы стать экспертом в этой области, однако мы попробуем сделать так, чтобы вам было понятно то, что происходит в этом руководстве.

Когда вы разрабатываете какое-либо приложение, вам следует использовать пространства имен (namespaces) и псевдонимы типов (type aliases), чтобы код было удобно читать. Мы начнем это делать позднее, после того, как у вас появится четкое понимание откуда берутся те или иные вещи. Поэтому первое время вы будете видеть что-то по типу `boost::asio::ip::tcp::socket`. Конечно же, в реальном коде это должно быть заменено на что-то вроде `tcp::socket`.

Двумя важными элементами сетевого взаимодействия являются *клиенты* и *серверы*. Обычно подобные руководства начинаются с изучения работы клиента, поскольку это более простая тема для рассмотрения. Однако в этом руководстве мы начнем с серверов. Почему? Во-первых, сервера — это то место, где C++ проявляет себя с наилучшей стороны, а во-вторых, сервера не так страшны, как кажутся на первый взгляд.

На этом вступление окончено. Теперь вы готовы приступить к погружению в сетевое программирование на C++.


<a id="orgd89f8a1"></a>

# TCP и UDP

Существует два основных протокола транспортного уровня, которые мы будем использовать — TCP и UDP. Протокол — это набор соглашений о том, как должны передаваться данные по сети.


<a id="org0185056"></a>

## Transmission Control Protocol — TCP

TCP-соединение очень похоже на файл: мы открываем его, считываем из него какие-то данные, записываем какие-то данные и закрываем его. Однако существуют некоторые ограничения:

-   При работе с файлом мы можем узнать его размер. В случае TCP-соединения это невозможно.
-   Вы можете изменять положение указателя, когда работаете с файлом. Этот трюк также нельзя провернуть с TCP-соединением.

Другими словами, файл предоставляет вам произвольный доступ, в то время как TCP-соединение представляет собой двунаправленный последовательный поток.


<a id="orga3ceb8c"></a>

## User Datagram Protocol — UDP

Информация, передаваемая по протоколу UDP, представляет собой непрерывный кусок данных. По сравнению с TCP, у UDP нет соединений. Невозможно получить только часть данных, отправленных приложением. Вы либо получите все данные, либо ничего. На данный момент вам нужно знать о UDP следующее:

-   В UDP отсутствуют соединения, поскольку это не поток данных. Из этого следует, что нет необходимости создавать или закрывать UDP-сокет. Все, что вам требуется — это отправлять или получать данные.
-   Буфер, используемый для получения UDP-пакета должен быть достаточно большим, чтобы вместить весь пакет целиком. В противном случае, вы ничего не получите. Из этого следует, что необходимо заранее знать верхнюю границу размера пакетов, которые вы собрались получать.
-   Порядок входящих пакетов, как правило, не соответствует порядку их отправки. Это означает, что необходимо самостоятельно контролировать порядок пакетов.
-   Нет никаких гарантий, что все отправленные пакеты будут доставлены. Это означает, что потеря UDP-пакетов — обычное дело. Следовательно, необходимо самостоятельно контролировать, что все отправленные UDP-пакеты доставлены.

Как вы можете понять, UDP немного сложнее в использовании, чем TCP. Тем не менее, у UDP есть свои преимущества, которые мы обсудим позднее.

Это все, что вам необходимо знать о протоколах на данный момент. Значит, мы можем двигаться дальше.

