- [Введение](#orgc0bdb41)
- [TCP и UDP](#orgf4a8b0d)
  - [Transmission Control Protocol — TCP](#orgada065f)
  - [User Datagram Protocol — UDP](#orgda8b0ee)
- [Самый простой сервер](#orgb5e4a0c)



<a id="orgc0bdb41"></a>

# Введение

Данное руководство посвящено работе асинхронного ввода-вывода, который в основном используется для сетевого взаимодействия. Для лучшего понимания происходящего, вы должны быть знакомы с современным C++, STL и Boost, а также с базовыми принципами сетевого взаимодействия и многопоточности.

Мы будем использовать `Boost.Asio`, `Boost.Beast`, а также `C++20 Networking library`. Чтобы добиться асинхронности, мы будем использовать *обработчики завершения*, *сопрограммы* (или корутины) и *фиберы*.

Чтобы скомпилировать исходный код из примеров, вам понадобиться установить компилятор, поддерживающий стандарт `C++17`, а также библиотеку `Boost`. При компиляции вам потребуется добавить `Boost` в `include directories` и слинковать исходный код вашего приложения с ним.

На самом деле, для большинства примеров достаточно скомпилировать `boost/libs/system/src/error_code.cpp`, поскольку остальная часть исходного кода библиотеки `Boost` — это header-only библиотеки.

Обычно сетевое взаимодействие считается очень сложным предметом для изучения. Неужели это действительно так сложно? Что ж, ответ — и да, и нет. Потребуется время, чтобы стать экспертом в этой области, однако мы попробуем сделать так, чтобы вам было понятно то, что происходит в этом руководстве.

Когда вы разрабатываете какое-либо приложение, вам следует использовать пространства имен (namespaces) и псевдонимы типов (type aliases), чтобы код было удобно читать. Мы начнем это делать позднее, после того, как у вас появится четкое понимание откуда берутся те или иные вещи. Поэтому первое время вы будете видеть что-то по типу `boost::asio::ip::tcp::socket`. Конечно же, в реальном коде это должно быть заменено на что-то вроде `tcp::socket`.

Двумя важными элементами сетевого взаимодействия являются *клиенты* и *серверы*. Обычно подобные руководства начинаются с изучения работы клиента, поскольку это более простая тема для рассмотрения. Однако в этом руководстве мы начнем с серверов. Почему? Во-первых, сервера — это то место, где C++ проявляет себя с наилучшей стороны, а во-вторых, сервера не так страшны, как кажутся на первый взгляд.

На этом вступление окончено. Теперь вы готовы приступить к погружению в сетевое программирование на C++.


<a id="orgf4a8b0d"></a>

# TCP и UDP

Существует два основных протокола транспортного уровня, которые мы будем использовать — TCP и UDP. Протокол — это набор соглашений о том, как должны передаваться данные по сети.


<a id="orgada065f"></a>

## Transmission Control Protocol — TCP

TCP-соединение очень похоже на файл: мы открываем его, считываем из него какие-то данные, записываем какие-то данные и закрываем его. Однако существуют некоторые ограничения:

-   При работе с файлом мы можем узнать его размер. В случае TCP-соединения это невозможно.
-   Вы можете изменять положение указателя, когда работаете с файлом. Этот трюк также нельзя провернуть с TCP-соединением.

Другими словами, файл предоставляет вам произвольный доступ, в то время как TCP-соединение представляет собой двунаправленный последовательный поток.


<a id="orgda8b0ee"></a>

## User Datagram Protocol — UDP

Информация, передаваемая по протоколу UDP, представляет собой непрерывный кусок данных. По сравнению с TCP, у UDP нет соединений. Невозможно получить только часть данных, отправленных приложением. Вы либо получите все данные, либо ничего. На данный момент вам нужно знать о UDP следующее:

-   В UDP отсутствуют соединения, поскольку это не поток данных. Из этого следует, что нет необходимости создавать или закрывать UDP-сокет. Все, что вам требуется — это отправлять или получать данные.
-   Буфер, используемый для получения UDP-пакета должен быть достаточно большим, чтобы вместить весь пакет целиком. В противном случае, вы ничего не получите. Из этого следует, что необходимо заранее знать верхнюю границу размера пакетов, которые вы собрались получать.
-   Порядок входящих пакетов, как правило, не соответствует порядку их отправки. Это означает, что необходимо самостоятельно контролировать порядок пакетов.
-   Нет никаких гарантий, что все отправленные пакеты будут доставлены. Это означает, что потеря UDP-пакетов — обычное дело. Следовательно, необходимо самостоятельно контролировать, что все отправленные UDP-пакеты доставлены.

Как вы можете понять, UDP немного сложнее в использовании, чем TCP. Тем не менее, у UDP есть свои преимущества, которые мы обсудим позднее.

Это все, что вам необходимо знать о протоколах на данный момент. Значит, мы можем двигаться дальше.


<a id="orgb5e4a0c"></a>

# Самый простой сервер

Согласно [Википедии](https://ru.wikipedia.org/wiki/Сервер_(программное_обеспечение)),

> Сервер — программный компонент вычислительной системы, выполняющий сервисные (обслуживающие) функции по запросу клиента, предоставляя ему доступ к определённым ресурсам или услугам.

Это определение очень точно подмечает тот факт, что сервер — это всего лишь приложение, которое получает какие-то данные от других приложений и возвращает некоторые данные обратно.

Мы начнем с самого простого сервера, который приходит на ум — эхо UDP-сервер. Он выполняет следующие действия:

-   Получает любые данные, которые были отправлены на UDP-порт 15001.
-   Отправляет полученные данные обратно отправителю «как есть».

На самом деле вы можете выбрать практически любой порт для вашего сервера. Существует множество часто используемых портов для различных служб, которые вы можете найти здесь: [Список портов TCP и UDP](https://ru.wikipedia.org/wiki/Список_портов_TCP_и_UDP). Однако, как правило, только несколько из этих служб используется одновременно в недавно установленной ОС.

Теперь давайте взглянем на следующий [исходный код](./code/simple_server.cpp):

```cpp
#include <boost/asio.hpp>

int main() {
    std::uint16_t port = 15001;

    boost::asio::io_context io_context;
    boost::asio::ip::udp::endpoint receiver(boost::asio::ip::udp::v4(), port);
    boost::asio::ip::udp::socket socket(io_context, receiver);

    while (true) {
        char buffer[65536];
        boost::asio::ip::udp::endpoint sender;
        std::size_t bytes_transferred =
            socket.receive_from(boost::asio::buffer(buffer), sender);
        socket.send_to(boost::asio::buffer(buffer, bytes_transferred), sender);
    }

    return 0;
}
```

Вам даже не обязательно отдельно скачивать `.cpp` файл сервера, поскольку вышеприведенный код — это полноценный эхо UDP-сервер. Мы не реализовали логирование и обработку ошибок, чтобы код выглядел максимально просто. Об обработке ошибок мы поговорим позднее. Давайте разберемся, что происходит в этом коде:

-   `boost::asio::io_context` — основной поставщик услуг ввода-вывода. В данный момент вы можете рассматривать его как исполнителя (executor) запланированных задач. Вы поймете его назначение сразу после того, как мы перейдем к асинхронному потоку управления, что произойдет очень скоро.
-   `boost::asio::ip::udp::endpoint` — это пара IP-адреса и порта.
-   `boost::asio::ip::udp::socket` — это сокет. Вы можете рассматривать его как дескриптор файла, предназначенный для сетевого взаимодействия. Обычно, когда вы открываете файл, вы получаете дескриптор файла. Когда вы взаимодействуете по сети, вы используете сокет.
-   Каждый сокет прикреплен к некоторому `io_context`, а потому каждый сокет конструируется с помощью ссылки на `io_context`. Второй параметр конструктора сокета — `endpoint` — IP-адрес и порт, который используется для получения входящих дейтаграмм (в случае UDP) или соединений (в случае TCP).
-   `boost::asio::ip::udp::v4()` возвращает объект, который в данный момент вы должны рассматривать как просто сетевой интерфейс UDP по умолчанию.
-   `boost::asio::buffer()` — это представление буфера, которое содержит указатель и размер, причем это представление не владеет памятью. В нашем случае оно указывает на массив `char`.
-   `socket::receive_from` ожидает входящий UDP-пакет, заполняет `buffer` полученными данными, а также заполняет `sender` информацией об отправителе, которая также включает в себя пару IP-адреса и порта.
-   `socket::send_to` отправляет UDP-пакет, используя данные из представления буфера. Получатель пакета передается вторым аргументом. В нашем случае получателем является отправитель, поскольку речь идет об эхо-сервере.

Итак, мы сделали следующее:

-   Создали UDP-сокет и настроили его на ожидание UDP-пакетов на порту 15001.
-   Запустили бесконечный цикл, в котором ожидаем входящие UDP-пакеты, а после получения отправляем их обратно отправителю.

Поздравляем! Вы только что создали ваш первый сервер с помощью C++ и Boost.Asio!
